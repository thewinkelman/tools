# analysis.cfg - configuration file for clients reporting to Xymon
#
# This file is used by the xymond_client module, when it builds the
# cpu, disk, files, memory, msgs and procs status messages from the
# information reported by clients running on the monitored systems.
#
# This file must be installed on the Xymon server - client installations
# do not need this file.
#
# The file defines a series of rules:
#    UP     : Changes the "cpu" status when the system has rebooted recently,
#             or when it has been running for too long.
#    LOAD   : Changes the "cpu" status according to the system load.
#    CLOCK  : Changes the "cpu" status if the client system clock is
#             not synchronized with the clock of the Xymon server.
#    DISK   : Changes the "disk" status, depending on the amount of space
#             used of filesystems.
#    MEMPHYS: Changes the "memory" status, based on the percentage of real
#             memory used.
#    MEMACT : Changes the "memory" status, based on the percentage of "actual"
#             memory used. Note: Not all systems report an "actual" value.
#    MEMSWAP: Changes the "memory" status, based on the percentage of swap
#             space used.
#    PROC   : Changes the "procs" status according to which processes were found
#             in the "ps" listing from the client.
#    LOG    : Changes the "msgs" status according to entries in text-based logfiles.
#             Note: The "client-local.cfg" file controls which logfiles the client will report.
#    FILE   : Changes the "files" status according to meta-data for files.
#             Note: The "client-local.cfg" file controls which files the client will report.
#    DIR    : Changes the "files" status according to the size of a directory.
#             Note: The "client-local.cfg" file controls which directories the client will report.
#    PORT   : Changes the "ports" status according to which tcp ports were found
#             in the "netstat" listing from the client.
#    DEFAULT: Set the default values that apply if no other rules match.
#
# All rules can be qualified so they apply only to certain hosts, or on certain
# times of the day (see below).
#
# Each type of rule takes a number of parameters:
#    UP bootlimit toolonglimit
#             The cpu status goes yellow if the system has been up for less than
#             "bootlimit" time, or longer than "toolonglimit". The time is in
#             minutes, or you can add h/d/w for hours/days/weeks - eg. "2h" for
#             two hours, or "4w" for 4 weeks.
#             Defaults: bootlimit=1h, toolonglimit=-1 (infinite).
#
#    LOAD warnlevel paniclevel
#             If the system load exceeds "warnlevel" or "paniclevel", the "cpu"
#             status will go yellow or red, respectively. These are decimal
#             numbers.
#             Defaults: warnlevel=5.0, paniclevel=10.0
#
#    CLOCK maximum-offset
#             If the system clock of the client differs from that of the Xymon
#             server by more than "maximum-offset" seconds, then the CPU status
#             column will go yellow. Note that the accuracy of this test is limited,
#             since it is affected by the time it takes a client status report to
#             go from the client to the Xymon server and be processed. You should
#             therefore allow for a few seconds (5-10) of slack when you define
#             your max. offset.
#             It is not wise to use this test, unless your servers are synchronized
#             to a common clock, e.g. through NTP.
#
#    DISK filesystem warnlevel paniclevel
#    DISK filesystem IGNORE
#             If the utilization of "filesystem" is reported to exceed "warnlevel"
#             or "paniclevel", the "disk" status will go yellow or red, respectively.
#             "warnlevel" and "paniclevel" are either the percentage used, or the
#             space available as reported by the local "df" command on the host.
#             For the latter type of check, the "warnlevel" must be followed by the
#             letter "U", e.g. "1024U".
#             The special keyword "IGNORE" causes this filesystem to be ignored
#             completely, i.e. it will not appear in the "disk" status column and
#             it will not be tracked in a graph. This is useful for e.g. removable
#             devices, backup-disks and similar hardware.
#             "filesystem" is the mount-point where the filesystem is mounted, e.g.
#             "/usr" or "/home". A filesystem-name that begins with "%" is interpreted
#             as a Perl-compatible regular expression; e.g. "%^/oracle.*/" will match
#             any filesystem whose mountpoint begins with "/oracle".
#             Defaults: warnlevel=90%, paniclevel=95%
#
#    MEMPHYS warnlevel paniclevel
#    MEMACT warnlevel paniclevel
#    MEMSWAP warnlevel paniclevel
#             If the memory utilization exceeds the "warnlevel" or "paniclevel", the
#             "memory" status will change to yellow or red, respectively.
#             Note: The words "PHYS", "ACT" and "SWAP" are also recognized.
#             Defaults: MEMPHYS warnlevel=100 paniclevel=101 (i.e. it will never go red)
#                       MEMSWAP warnlevel=50 paniclevel=80
#                       MEMACT  warnlevel=90 paniclevel=97
#
#    PROC processname minimumcount maximumcount color [TRACK=id] [TEXT=displaytext]
#             The "ps" listing sent by the client will be scanned for how many
#             processes containing "processname" are running, and this is then
#             matched against the min/max settings defined here. If the running
#             count is outside the thresholds, the color of the "procs" status
#             changes to "color".
#             To check for a process that must NOT be running: Set minimum and
#             maximum to 0.
#
#             "processname" can be a simple string, in which case this string must
#             show up in the "ps" listing as a command. The scanner will find
#             a ps-listing of e.g. "/usr/sbin/cron" if you only specify "processname"
#             as "cron".
#             "processname" can also be a Perl-compatiable regular expression, e.g.
#             "%java.*inst[0123]" can be used to find entries in the ps-listing for
#             "java -Xmx512m inst2" and "java -Xmx256 inst3". In that case,
#             "processname" must begin with "%" followed by the reg.expression.
#             If "processname" contains whitespace (blanks or TAB), you must enclose
#             the full string in double quotes - including the "%" if you use regular
#             expression matching. E.g.
#                 PROC "%xymond_channel --channel=data.*xymond_rrd" 1 1 yellow
#             or
#                 PROC "java -DCLASSPATH=/opt/java/lib" 2 5
#
#             You can have multiple "PROC" entries for the same host, all of the
#             checks are merged into the "procs" status and the most severe
#             check defines the color of the status.
#
#             The TRACK=id option causes the number of processes found to be recorded
#             in an RRD file, with "id" as part of the filename. This graph will then
#             appear on the "procs" page as well as on the "trends" page. Note that
#             "id" must be unique among the processes tracked for each host.
#
#             The TEXT=displaytext option affects how the process appears on the
#             "procs" status page. By default, the process is listed with the
#             "processname" as identification, but if this is a regular expression
#             it may be a bit difficult to understand. You can then use e.g.
#             "TEXT=Apache" to make these processes appear with the name "Apache"
#             instead.
#
#             Defaults: mincount=1, maxcount=-1 (unlimited), color="red".
#                       Note: No processes are checked by default.
#
#             Example: Check that "cron" is running:
#                 PROC cron
#             Example: Check that at least 5 "httpd" processes are running, but
#             not more than 20:
#                 PROC httpd 5 20
#
#    LOG filename match-pattern [COLOR=color] [IGNORE=ignore-pattern] [TEXT=displaytext]
#             In the "client-local.cfg" file, you can list any number of files
#             that the client will collect log data from. These are sent to the
#             Xymon server together with the other client data, and you can then
#             choose how to analyze the log data with LOG entries.
#
#                             ************ IMPORTANT ***************
#             To monitor a logfile, you *MUST* configure both client-local.cfg
#             and analysis.cfg. If you configure only the client-local.cfg
#             file, the client will collect the log data and you can view it in
#             the "client data" display, but it will not affect the color of the
#             "msgs" status. On the other hand, if you configure only the
#             analysis.cfg file, then there will be no log data to inspect,
#             and you will not see any updates of the "msgs" status either.
#
#             "filename" is a filename or pattern. The set of files reported by
#             the client is matched against "filename", and if they match then
#             this LOG entry is processed against the data from a file.
#
#             "match-pattern": The log data is matched against this pattern. If
#             there is a match, this log file causes a status change to "color".
#
#             "ignore-pattern": The log data that matched "match-pattern" is also
#             matched against "ignore-pattern". If the data matches the "ignore-pattern",
#             this line of data does not affect the status color. In other words,
#             the "ignore-pattern" can be used to refine the strings which cause
#             a match.
#             Note: The "ignore-pattern" is optional.
#
#             "color": The color which this match will trigger.
#             Note: "color" is optional, if omitted then "red" will be used.
#
#             Example: Go yellow if the text "WARNING" shows up in any logfile.
#                 LOG %.* WARNING COLOR=yellow
#
#             Example: Go red if the text "I/O error" or "read error" appears.
#                 LOG %/var/(adm|log)/messages %(I/O|read).error COLOR=red
#
#    FILE filename [color] [things to check] [TRACK]
#             NB: The files you wish to monitor must be listed in a "file:..."
#             entry in the client-local.cfg file, in order for the client to
#             report any data about them.
#
#             "filename" is a filename or pattern. The set of files reported by
#             the client is matched against "filename", and if they match then
#             this FILE entry is processed against the data from that file.
#
#             [things to check] can be one or more of the following:
#             - "NOEXIST" triggers a warning if the file exists. By default,
#               a warning is triggered for files that have a FILE entry, but
#               which do not exist.
#             - "TYPE=type" where "type" is one of "file", "dir", "char", "block",
#               "fifo", or "socket". Triggers warning if the file is not of the
#               specified type.
#             - "OWNERID=owner" and "GROUPID=group" triggers a warning if the owner
#               or group does not match what is listed here. "owner" and "group" is
#               specified either with the numeric uid/gid, or the user/group name.
#             - "MODE=mode" triggers a warning if the file permissions are not
#               as listed. "mode" is written in the standard octal notation, e.g.
#               "644" for the rw-r--r-- permissions.
#             - "SIZE<max.size" and "SIZE>min.size" triggers a warning it the file
#               size is greater than "max.size" or less than "min.size", respectively.
#               You can append "K" (KB), "M" (MB), "G" (GB) or "T" (TB) to the size.
#               If there is no such modifier, KB is assumed.
#               E.g. to warn if a file grows larger than 1MB (1024 KB): "SIZE<1M".
#             - "SIZE=size" triggers a warning it the file size is not what is listed.
#             - "MTIME>min.mtime" and "MTIME<max.mtime" checks how long ago the file
#               was last modified (in seconds). E.g. to check if a file was updated
#               within the past 10 minutes (600 seconds): "MTIME<600". Or to check
#               that a file has NOT been updated in the past 24 hours: "MTIME>86400".
#             - "MTIME=timestamp" checks if a file was last modified at "timestamp".
#               "timestamp" is a unix epoch time (seconds since midnight Jan 1 1970 UTC).
#             - "CTIME>min.ctime", "CTIME<max.ctime", "CTIME=timestamp" acts as the
#               mtime checks, but for the ctime timestamp (when the files' directory
#               entry was last changed, eg. by chown, chgrp or chmod).
#             - "MD5=md5sum", "SHA1=sha1sum", "RMD160=rmd160sum" trigger a warning
#               if the file checksum using the MD5, SHA1 or RMD160 message digest
#               algorithms do not match the one configured here. Note: The "file"
#               entry in the client-local.cfg file must specify which algorithm to use.
#
#             "TRACK" causes the size of this file to be tracked in an RRD file, and
#             shown on the graph on the "files" display.
#
#             Example: Check that the /var/log/messages file is not empty and was updated
#                      within the past 10 minutes, and go yellow if either fails:
#                 FILE /var/log/messages SIZE>0 MTIME<600 yellow
#
#             Example: Check the timestamp, size and SHA-1 hash of the /bin/sh program:
#                 FILE /bin/sh MTIME=1128514608 SIZE=645140 SHA1=5bd81afecf0eb93849a2fd9df54e8bcbe3fefd72
#
#    DIR directory [color] [SIZE<maxsize] [SIZE>minsize] [TRACK]
#             NB: The directories you wish to monitor must be listed in a "dir:..."
#             entry in the client-local.cfg file, in order for the client to
#             report any data about them.
#
#             "directory" is a filename or pattern. The set of directories reported by
#             the client is matched against "directory", and if they match then
#             this DIR entry is processed against the data for that directory.
#
#             "SIZE<maxsize" and "SIZE>minsize" defines the size limits that the
#             directory must stay within. If it goes outside these limits, a warning
#             will trigger. Note the Xymon uses the raw number reported by the
#             local "du" command on the client. This is commonly KB, but it may be
#             disk blocks which are often 512 bytes.
#
#             "TRACK" causes the size of this directory to be tracked in an RRD file,
#             and shown on the graph on the "files" display.
#
#    PORT [LOCAL=addr] [EXLOCAL=addr] [REMOTE=addr] [EXREMOTE=addr] [STATE=state] [EXSTATE=state] [MIN=mincount] [MAX=maxcount] [COLOR=color] [TRACK=id] [TEXT=displaytext]
#             The "netstat" listing sent by the client will be scanned for how many
#             sockets match the criteria listed.
#             "addr" is a (partial) address specification in the format used on
#             the output from netstat. This is typically "10.0.0.1:80" for the IP
#             10.0.0.1, port 80. Or "*:80" for any local address, port 80.
#             NB: The Xymon clients normally report only the numeric data for
#                 IP-adresses and port-numbers, so you must specify the port
#                 number (e.g. "80") instead of the service name ("www").
#             "state" causes only the sockets in the specified state to be included;
#             it is usually LISTEN or ESTABLISHED.
#             The socket count is then matched against the min/max settings defined
#             here. If the count is outside the thresholds, the color of the "ports"
#             status changes to "color".
#             To check for a socket that must NOT exist: Set minimum and
#             maximum to 0.
#
#             "addr" and "state" can be a simple strings, in which case these string must
#             show up in the "netstat" at the appropriate column.
#             "addr" and "state" can also be a Perl-compatiable regular expression, e.g.
#             "LOCAL=%(:80|:443)" can be used to find entries in the netstat local port for
#             both http (port 80) and https (port 443). In that case, portname or state must
#             begin with "%" followed by the reg.expression.
#
#             The TRACK=id option causes the number of sockets found to be recorded
#             in an RRD file, with "id" as part of the filename. This graph will then
#             appear on the "ports" page as well as on the "trends" page. Note that
#             "id" must be unique among the ports tracked for each host.
#
#             The TEXT=displaytext option affects how the port appears on the
#             "ports" status page. By default, the port is listed with the
#             local/remote/state rules as identification, but this may be somewhat
#             difficult to understand. You can then use e.g. "TEXT=Secure Shell" to make
#             these ports appear with the name "Secure Shell" instead.
#
#             Defaults: state="LISTEN", mincount=1, maxcount=-1 (unlimited), color="red".
#                       Note: No ports are checked by default.
#
#             Example: Check that there is someone listening on the https port:
#                 PORT "LOCAL=%([.:]443)$" state=LISTEN TEXT=https
#
#             Example: Check that at least 5 "ssh" connections are established, but
#             not more than 10; warn but do not error; graph the connection count:
#                 PORT "LOCAL=%([.:]22)$" state=ESTABLISHED min=5 max=20 color=yellow TRACK=ssh "TEXT=SSH logins"
#
#             Example: Check that ONLY ports 22, 80 and 443 are open for incoming connections:
#                 PORT STATE=LISTEN LOCAL=%0.0.0.0[.:].* EXLOCAL=%[.:](22|80|443)$ MAX=0 "TEXT=Bad listeners"
#
#
# To apply rules to specific hosts, you can use the "HOST=", "EXHOST=", "PAGE="
# "EXPAGE=", "CLASS=" or "EXCLASS=" qualifiers.  (These act just as in the
# alerts.cfg file).
#
# Hostnames are either a comma-separated list of hostnames (from the hosts.cfg file),
# "*" to indicate "all hosts", or a Perl-compatible regular expression.
# E.g. "HOST=dns.foo.com,www.foo.com" identifies two specific hosts;
# "HOST=%www.*.foo.com EXHOST=www-test.foo.com" matches all hosts with a name
# beginning with "www", except the "www-test" host.
# "PAGE" and "EXPAGE" match the hostnames against the page on where they are
# located in the hosts.cfg file, via the hosts' page/subpage/subparent
# directives. This can be convenient to pick out all hosts on a specific page.
#
# Rules can be dependant on time-of-day, using the standard Xymon syntax
# (the hosts.cfg(5) about the NKTIME parameter). E.g. "TIME=W:0800:2200"
# applied to a rule will make this rule active only on week-days between
# 8AM and 10PM.
#
# You can also associate a GROUP id with a rule. The group-id is passed to
# the alert module, which can then use it to control who gets an alert when
# a failure occurs. E.g. the following associates the "httpd" process check
# with the "web" group, and the "sshd" check with the "admins" group:
#    PROC httpd 5 GROUP=web
#    PROC sshd 1 GROUP=admins
# In the alerts.cfg file, you could then have rules like
#    GROUP=web
#       MAIL webmaster@foo.com
#    GROUP=admins
#       MAIL root@foo.com
#
# Qualifiers must be placed after each rule, e.g.
#    LOAD 8.0 12.0  HOST=db.foo.com TIME=*:0800:1600
#
# If you have multiple rules that you want to apply the same qualifiers to,
# you can write the qualifiers *only* on one line, followed by the rules. E.g.
#    HOST=%db.*.foo.com TIME=W:0800:1600
#       LOAD 8.0 12.0
#       DISK /db  98 100
#       PROC mysqld 1
# will apply the three rules to all of the "db" hosts on week-days between 8AM
# and 4PM. This can be combined with per-rule qualifiers, in which case the
# per-rule qualifier overrides the general qualifier; e.g.
#    HOST=%.*.foo.com
#       LOAD 7.0 12.0 HOST=bax.foo.com
#       LOAD 3.0 8.0
# will result in the load-limits being 7.0/12.0 for the "bax.foo.com" host,
# and 3.0/8.0 for all other foo.com hosts.
#
# The special DEFAULT section can modify the built-in defaults - this must
# be placed at the end of the file.


#vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
# HINT: use 'xymoncmd xymond_client --test'
# to see how this file is parsed
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

########################################################################
# PORT MONITORS
#
# Please use existing monitors as examples for new ones; please try to
# adhere to the existing style and conventions.
#
# Please put port monitors in port-number order.
#
# Most monitored ports are intended to serve clients elsewhere on the
# network ("LAN-facing"), not just on the machine hosting the port.
# When monitoring ports intended to serve the broader network, it is
# important to ignore ports listing only on loopback, so as to not
# incorrectly consider the port present even though it cannot serve the
# broader network.
#
# In general, the TRACK parameter should aggregate by service, not by
# port, such that if a single service is provided on several ports, each
# port should use the same TRACK ID.  The TRACK ID should reflect the
# name used in the TEXT parameter to describe the port, which in turn
# should reflect the name associated with the port in the /etc/services
# file, if accurate.
#
# A port in a LISTEN state is availble to accept connections, and
# indicates the service behind it is at least running.  The absense of a
# listening port when one is expected to be listening is likely a problem.
#
# A port in ESTABLISHED state represents service actively being provided
# by or to the port.  We generally don't care about the specific number
# of established connections, but like to track them to visualize the
# service's use.  In a few cases (notably for port 3306 (mysql)), we
# care if the established connection count gets high.
#
# We generally do not care about other port states, except when monitoring
# for unwanted ports: an unwanted port in any state is still unwanted.
#
# The TEXT parameter should provide a description of the port and
# service, sufficient to differentiate it unambiguously from all other
# port descriptions.  The description should include the port number
# and some indication of what the nature of the service provided by the
# port is.  Where reasonably accurate, the service description should
# be derived from the port name in the /etc/services file.
#
# Each port monitor that might produce an alert should specify a GROUP
# that roughly reflects the application domain (e.g. "pubsys", "escenic",
# "system").

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 21 (ftp) monitor
#
# FTP is something of a security risk, since it transmits credentials
# in plain-text.  It's also older technology, and we prefer to promote
# newer technologies for file transfer within the network.  Still, many
# of the markets and third-parties prefer and/or require the use of FTP,
# so we make it availble, but only on a limited set of machines.
#
# Port 21 (ftp) LAN-facing service is expected present on:
#
# * RHEL USR boxes: rusr\d{3}[dpt]
#
HOST=%^rusr\d{3}[dpt]\.
  PORT LOCAL=%:21$ EXLOCAL=127.0.0.1:21 STATE=LISTEN MIN=1 TRACK=ftp "TEXT=Port 21 (ftp), LAN-facing, listening" GROUP=system
  PORT LOCAL=%:21$ EXLOCAL=127.0.0.1:21 STATE=ESTABLISHED MIN=0 TRACK=ftp "TEXT=Port 21 (ftp), LAN-facing, established"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 22 (ssh) monitor
#
# SSH is our primary means of administrative interaction with the
# machines, and is a common means by which other technocal staff within MI
# and market staff interact with the machines for ancillary services not
# exposed through the web application interfaces.  SSH should be available
# on all RHEL systems.
#
# Port 22 (ssh) LAN-facing service is expected present on:
#
# * RHEL boxes: r\w{3}\d{3}[dpt]
#
HOST=%^r\w{3}\d{3}[dpt]\.
  PORT LOCAL=%:22$ EXLOCAL=127.0.0.1:22 STATE=LISTEN MIN=1 TRACK=ssh "TEXT=Port 22 (ssh), LAN-facing, listening" GROUP=system
  PORT LOCAL=%:22$ EXLOCAL=127.0.0.1:22 STATE=ESTABLISHED MIN=0 TRACK=ssh "TEXT=Port 22 (ssh), LAN-facing, established"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 25 (smtp) monitor
#
# RHEL systems operate an SMTP gateway to handle mail originating from the
# machine itself.  With this, individual mail clients on the machine need
# not be aware of a mail server elsewhere on the network, and can instead
# rely on the machine to forward it appropriately.
#
# The PUBADM servers, which act as mail relays for the entire network,
# do not listen specifically on 127.0.0.1, so the local-only monitoring
# will fail there, and so shouldn't occur there.  Select ADM servers
# with a presence on the local admin subnet also provide relay service
# for admin hosts, and will have the same port presence as PUBADM.
#
# Unsanctioned servers offering LAN-facing port 25 (smtp) service may
# be hijacked by spammers or may provide other unsanctioned relaying.
#
# Port 25 (smtp) local-only service is expected present on:
#
# * RHEL boxes: r\w{3}\d{3}[dpt]
#
# but not on:
#
# * RHEL PUBADM boxes: rutl01[0-2]p
# * admin net relays: radm001p
#
HOST=%^r\w{3}\d{3}[dpt]\. EXHOST=%^r(adm001|utl01[0-2])p\.
  PORT LOCAL=127.0.0.1:25 STATE=LISTEN MIN=1 TRACK=smtp "TEXT=Port 25 (smtp), local-only, listening" GROUP=system
#
# As noted above, the PUBADM servers are mail gateways for the entire
# network: those local mail gateways all forward to the PUBADM servers,
# which in turn forward on to external destinations.  Select ADM servers
# also provide relaying for the admin subnet.
#
# Port 25 (smtp) LAN-facing service is expected present on:
#
# * RHEL PUBADM boxes: rutl01[0-2]p
# * admin net relays: radm001p
#
HOST=%^r(adm001|utl01[0-2])p\.
  PORT LOCAL=%:25$ EXLOCAL=127.0.0.1:25 STATE=LISTEN MIN=1 TRACK=smtp "TEXT=Port 25 (smtp), LAN-facing, listening" GROUP=mail
  PORT LOCAL=%:25$ EXLOCAL=127.0.0.1:25 STATE=ESTABLISHED MIN=0 TRACK=smtp "TEXT=Port 25 (smtp), LAN-facing, established"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 53 (domain) monitor
#
# RHEL systems should have a local caching nameserver on 127.0.0.1:53.
# Since the only client for the local caching server is the machine
# itself, we care only that the service is present (STATE=LISTEN) and
# not how much it's being used (STATE=ESTABLISHED).
#
# Port 53 (domain) local-only service is expected present on:
#
# * RHEL boxes: r\w{3}\d{3}[dpt]
#
HOST=%^r\w{3}\d{3}[dpt]\.
  PORT LOCAL=127.0.0.1:53 STATE=LISTEN MIN=1 TRACK=domain "TEXT=Port 53 (domain), local-only, listening" GROUP=system
#
# DNS infrastructure (master and slaves) should be providing remote-facing
# DNS service.  The master services requests from the slaves (and is
# available for other internal use); the slaves service other systems
# within the network, as well as requests from the public through the
# load-balancers.
#
# Port 53 (domain) LAN-facing service is expected present on:
#
# * DNS master: radm001p
# * PUBADM servers (DNS slaves): rutl01[0-2]p
# * remote DNS server: rutl40[0,2]p
#
HOST=%^r(adm001|utl(01[0-2]|048|40[0,2]))p\.
  PORT LOCAL=%:53$ EXLOCAL=127.0.0.1:53 STATE=LISTEN MIN=1 TRACK=domain "TEXT=Port 53 (domain), LAN-facing, listening" GROUP=dns
  PORT LOCAL=%:53$ EXLOCAL=127.0.0.1:53 STATE=ESTABLISHED MIN=0 TRACK=domain "TEXT=Port 53 (domain), LAN-facing, established"
  PROC /usr/sbin/named 1 TRACK=named
#
# Any box running libvirtd (which for MI is any KVM host) will run
# dnsmasq to provide DNS service to guests via 192.168.122.1.
#
# Port 53 (domain) service via 192.168.122.1 is expected present on:
#
# * RHEL KVM hosts: rvrt\d{3}[dpt]
#
# but not on:
#
# * rvrt000d (VirtualBox host)
# * rvrt001d (Vagrant host)
#
# Since the service is only intended for local KVM guests and
# is not accessible off the KVM host itself we care only that the
# service is present (STATE=LISTEN) and not how much it's being used
# (STATE=ESTABLISHED).
#
HOST=%^rvrt\d{3}[dpt]\. EXHOST=%^rvrt00[01]d\.
  PORT LOCAL=192.168.122.1:53 STATE=LISTEN MIN=1 TRACK=domain "TEXT=Port 53 (domain), KVM-local, listening" GROUP=system

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 80 (http) monitor
#
# Port 80 (http) is widely used, and HTTP servers tend to be very
# full-featured, making them popular targets for attack.  We want to
# know where port 80 is in use, and we want to make sure its presence
# matches our expectations.  If present where expected absent,
# that's bad.  If absent where expected present, that's bad.  Otherwise,
# is good.
#
# The distribution of port 80 throughout the MI network is complicated,
# so the monitoring rules are complicated.  Take care adjusting monitoring
# for port 80.  Please also be sure to document the rationale for your
# decisions, so as to not add unduely to the complexity.
#
# RHEL WEB and PXY servers all provide HTTP service on port 80 (http)
# inherently.
#
# RHEL SVC servers, and non-3 RHEL CGI servers, primarily provide
# HTTP service on other ports, but daemon status is provided through
# port 80.
#
# Production
#
# Port 80 (http) LAN-facing service is expected present on:
#
# * cobbler0: radm007p
# * Escenic "dark" host: rutl047p
# * hdb, puppet0, wiki: rutl03[67]p
# * Pooling servers: rutl02[12]p
# * RHEL CGI servers: rcgi\d{3}p
# * RHEL PRE servers: rpre\d{3}p except for rpre000p
# * RHEL PXY servers: rpxy\d{3}p
# * RHEL SVC servers: rsvc\d{3}p
# * RHEL WEB servers: rweb\d{3}p
# * Shibboleth server: rutl017p
# * Statistics server: rutl002p
# * xymon0: radm003p
# * yum0: radm002p
#
HOST=%^radm00[237]p\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN MIN=1 TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=system
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#
HOST=%^rutl0(02|17|36|47)p\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN MIN=1 TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=devops
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#
HOST=%^r((pxy|svc|web)\d{3}|pre\d(0[1-9]|\d(?<!0)\d))p\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN MIN=1 TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=pubsys
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#
HOST=%^rcgi\d{3}p\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN MIN=1 TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=pubsys
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#
# QA
#
# Port 80 (http) LAN-facing service is expected present on:
#
# * puppet0: rutl0(06|18)t
# * RHEL CGI servers: rcgi\d{3}t (PubSys)
# * RHEL DRP servers: rdrp\d{3}t (Drupal)
# * RHEL PRE servers: rpre\d{3}t (Escenic)
# * RHEL PXY servers: rpxy\d{3}t (shared)
# * RHEL SVC servers: rsvc\d{3}t (PubSys)
# * RHEL WEB servers: rweb\d{3}t (shared)
#
HOST=%^rutl0(06|18)t\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN MIN=1 TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=puppet
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#
HOST=%^rsvc\d{3}t\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN MIN=1 TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=pubsys
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#
HOST=%^r(pre\d{3})t\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN MIN=1 TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=escenic
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#
HOST=%^r(pxy\d{3})t\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN MIN=1 TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=devops
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#
HOST=%^r(web\d{3})t\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN MIN=1 TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=support
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#
# Development
#
# Port 80 (http) LAN-facing service is expected present on:
#
# * DevOps sites: rutl0(30|0[17])d
# * relnotes: rutl008d
# * RHEL DRP servers: rdrp\d{3}d
# * RHEL PRE servers: rpre\d{3}d (Escenic)
# * RHEL PXY servers: rpxy\d{3}d
# * RHEL SVC servers: rsvc\d{3}d
# * RHEL WEB servers: rweb\d{3}d
#
HOST=%^rutl0(30|0[17])d\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=devops
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#
HOST=%^r((drp|pre|pxy|svc|web)\d{3}|utl008)d\.
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=LISTEN TRACK=http "TEXT=Port 80 (http), LAN-facing, listening" GROUP=pubsys
  PORT LOCAL=%:80$ EXLOCAL=127.0.0.1:80 STATE=ESTABLISHED MIN=0 TRACK=http "TEXT=Port 80 (http), LAN-facing, established"
#

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 111 (sunrpc) monitor
#
# A variety of services integral to our operation, such as NIS and NFS,
# make use of RPC-based services.  Port 111 (sunrpc) typically hosts
# portmapper, which directs RPC-based requests to an appropriate server
# on another local port to handle the request.
#
# All RHEL boxes require port 111 (sunprc).
#
# Port 111 (sunrpc) LAN-facing service is expected present on:
#
# * RHEL boxes: r\w{3}\d{3}[dpt]
#
HOST=%^r\w{3}\d{3}[dpt]\.
  PORT LOCAL=%:111$ EXLOCAL=127.0.0.1:111 STATE=LISTEN MIN=1 TRACK=sunrpc "TEXT=Port 111 (sunrpc), LAN-facing, listening" GROUP=system

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 953 (rndc)
#
# All servers that run a local caching nameserver (as described for local
# port 53, above) should also be listening (locally) for connections on
# the remote name daemon control (RNDC) port, port 953.  We only care
# that the listener is present (STATE=LISTEN), not how much it is used
# (STATE=ESTABLISHED).
#
# Port 953 (rndc) local-only service is expected present on:
#
# * RHEL boxes: r\w{3}\d{3}[dpt]
#
HOST=%^r\w{3}\d{3}[dpt]\.
  port locAL=127.0.0.1:953 STATE=LISTEN MIN=1 TRACK=rndc "TEXT=Port 953 (rndc), local-only, listening" GROUP=system

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 3306 (mysql) monitor
#
# DBX servers host databases for use over the network.  All RHEL DBX
# boxes should be providing LAN-facing (MySQL) connectivity.
#
# Port 3306 (mysql) LAN-facing service is expected present on:
#
# * RHEL database servers: rdbx\d{3}[dpt]
#
HOST=%^rdbx\d{3}[dpt]\.
  PORT LOCAL=%:3306$ EXLOCAL=127.0.0.1:3306 STATE=LISTEN MIN=1 TRACK=mysql "TEXT=Port 3306 (mysql), LAN-facing, listening" GROUP=db
  PORT LOCAL=%:3306$ EXLOCAL=127.0.0.1:3306 STATE=ESTABLISHED MIN=0 MAX=3000 COLOR=yellow TRACK=mysql "TEXT=Port 3306 (mysql), LAN-facing, established"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 8080 (tomcat) monitor
#
# Port 8080 is widely by Java applications running through Tomcat.
#
# Escenic presentation (PRE) and publication (PUB) server classes both
# run Tomcat and provide service on port 8080.  Unfortunately. while
# the PRE class is unique to Escenic, PUB is also used by PubSys, so
# the rules for monitoring Escenic PUB systems must take care to exclude
# PubSys PUB systems.
#
# Outside of production, Escenic PUB and PRE service may also be provided
# by other server classes.
#
# Jira, also running under Tomcat, listens on port 8080.
#
# Port 8080 (tomcat) LAN-facing service is expected on:
#
# * Escenic sandbox: rutl003d
# * Escenic presentation: rpre\d{3}[dpt]
# * Escenic publication: rpub014d, rpub00[0579]p, rpub008t, rpub012t, rpub013t, rpub015t, rutl025d
# * Escenic statistics: rutl028d, rutl0(00|27)p, rutl052t, rutl046t, rutl045t
# * DPE web: rdpw\d{3}[dpt]
# * Jira: rutl032d, rutl040p
#
HOST=%^rutl003d\.
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=LISTEN MIN=1 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, listening" GROUP=devops
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=ESTABLISHED MIN=0 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, established"
#
HOST=%^rutl0(32d|40p)\.
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=LISTEN MIN=1 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, listening" GROUP=jira
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=ESTABLISHED MIN=0 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, established"
#
HOST=%^r(pre\d{3}|pub014|utl02[58])d\.
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=LISTEN MIN=1 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, listening" GROUP=escenic
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=ESTABLISHED MIN=0 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, established"
#
HOST=%^r(pre\d{3}|pub0(08|1[235])|utl0(4[56]|52))t\.
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=LISTEN MIN=1 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, listening" GROUP=escenic
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=ESTABLISHED MIN=0 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, established"
#
HOST=%^r(pre\d{3}|pub00[0579]|utl0(00|27))p\.
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=LISTEN MIN=1 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, listening" GROUP=escenic
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=ESTABLISHED MIN=0 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, established"
#
HOST=%^rdp[aw]\d{3}[dpt]\.
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=LISTEN MIN=1 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, listening" GROUP=dpe
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=ESTABLISHED MIN=0 TRACK=tomcat "TEXT=Port 8080 (tomcat), LAN-facing, established"
#
# Prior to Tomcat's emergence as a user of port 8080, the port was
# intended for use by web caching services (per /etc/services).  Varnish,
# serving the Digital Publishing Engine (DPE) infrastructure, uses port
# 8080, but isn't a Java app running under Tomcat.
#
# Port 8080 (varnish-dpe) LAN-facing service is expected on:
#
# * Varnish servers: rpxy006p, rpxy010p, rpxy005t, rpxy012t, rpxy020t
#                    rpxy021p
#
# Note: Varnish for Solr is transparent and will listen on Solr port
#
HOST=%^rpxy0(05|1[2])t\.
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 MIN=1 TRACK=varnish-dpe "TEXT=Port 8080 (varnish-dpe), LAN-facing, listening" GROUP=dpe
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=ESTABLISHED MIN=0 TRACK=varnish-dpe "TEXT=Port 8080 (varnish-dpe), LAN-facing, established"
#
HOST=%^rpxy0(06|10|2[01])p\.
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 MIN=1 TRACK=varnish-dpe "TEXT=Port 8080 (varnish-dpe), LAN-facing, listening" GROUP=dpe
  PORT LOCAL=%:8080$ EXLOCAL=127.0.0.1:8080 STATE=ESTABLISHED MIN=0 TRACK=varnish-dpe "TEXT=Port 8080 (varnish-dpe), LAN-facing, established"
#
# Corporate pooling servers are lightly used, so we don't bother to
# differentiate types of connections.
#
#

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 8083 (varnish-ece)
#
# Varnish uses port 8083 in service to the Escenic infrastructure.
#
# Port 8083 (varnish-ece) LAN-facing service is expected present on:
#
# * Varnish servers: rpxy007d, rpxy006p, rpxy010p, rpxy005t, rpxy012t,
#                    rpxy012t, rpxy016t, rpxy017t, rpxy018t, rpxy019t
#                    rpxy020p, rpxy021p
#
HOST=%^rpxy007d\.
  PORT LOCAL=%:8083$ EXLOCAL=127.0.0.1:8083 MIN=1 TRACK=varnish-ece "TEXT=Port 8083 (varnish-ece), LAN-facing, listening" GROUP=varnish
  PORT LOCAL=%:8083$ EXLOCAL=127.0.0.1:8083 STATE=ESTABLISHED MIN=0 TRACK=varnish-ece "TEXT=Port 8083 (varnish-ece), LAN-facing, established"
#
HOST=%^rpxy0(05|1[26789])t\.
  PORT LOCAL=%:8083$ EXLOCAL=127.0.0.1:8083 MIN=1 TRACK=varnish-ece "TEXT=Port 8083 (varnish-ece), LAN-facing, listening" GROUP=varnish
  PORT LOCAL=%:8083$ EXLOCAL=127.0.0.1:8083 STATE=ESTABLISHED MIN=0 TRACK=varnish-ece "TEXT=Port 8083 (varnish-ece), LAN-facing, established"
#
HOST=%^rpxy0(06|10|2[01])p\.
  PORT LOCAL=%:8083$ EXLOCAL=127.0.0.1:8083 MIN=1 TRACK=varnish-ece "TEXT=Port 8083 (varnish-ece), LAN-facing, listening" GROUP=varnish
  PORT LOCAL=%:8083$ EXLOCAL=127.0.0.1:8083 STATE=ESTABLISHED MIN=0 TRACK=varnish-ece "TEXT=Port 8083 (varnish-ece), LAN-facing, established"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 8888 (varnish)
#
# Varnish uses port 8888 for cross-server caching, to see if peers have
# cached content before reaching back to origin.
#
# Port 8888 (varnish) LAN-facing service is expected present on:
#
# * Varnish servers: rpxy007d, rpxy006p, rpxy010p, rpxy020p, rpxy021p,
#                    rpxy005t, rpxy012t, rpxy016t, rpxy017t, rpxy018t,
#                    rpxy019t
#
HOST=%^rpxy007d\.
  PORT LOCAL=%:8888$ EXLOCAL=127.0.0.1:8888 MIN=1 TRACK=varnish "TEXT=Port 8888 (varnish), LAN-facing, listening" GROUP=varnish
  PORT LOCAL=%:8888$ EXLOCAL=127.0.0.1:8888 STATE=ESTABLISHED MIN=0 TRACK=varnish "TEXT=Port 8888 (varnish), LAN-facing, established"
#
HOST=%^rpxy0(05|1[26789])t\.
  PORT LOCAL=%:8888$ EXLOCAL=127.0.0.1:8888 MIN=1 TRACK=varnish "TEXT=Port 8888 (varnish), LAN-facing, listening" GROUP=varnish
  PORT LOCAL=%:8888$ EXLOCAL=127.0.0.1:8888 STATE=ESTABLISHED MIN=0 TRACK=varnish "TEXT=Port 8888 (varnish), LAN-facing, established"
#
HOST=%^rpxy0(06|10|2[01])p\.
  PORT LOCAL=%:8888$ EXLOCAL=127.0.0.1:8888 MIN=1 TRACK=varnish "TEXT=Port 8888 (varnish), LAN-facing, listening" GROUP=varnish
  PORT LOCAL=%:8888$ EXLOCAL=127.0.0.1:8888 STATE=ESTABLISHED MIN=0 TRACK=varnish "TEXT=Port 8888 (varnish), LAN-facing, established"
#

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 8983 (solr) monitor
#
# Solr runs on dedicated SLR servers and Varnish used as Solr cache
#
# Port 8983 (solr) LAN-facing service is expected present on:
#
# * RHEL SLR boxes: rslr\d{3}[dpt]
# * Varnish servers caching Solr: rpxy014p, rpxy015p, rpxy011t, rpxy013t
#                                 rpxy022t, rpxy023t
#
HOST=%^rslr\d{3}d\.
  PORT LOCAL=%:8983$ EXLOCAL=127.0.0.1:8983 STATE=LISTEN MIN=1 TRACK=solr "TEXT=Port 8983 (solr), LAN-facing, listening" GROUP=solr
  PORT LOCAL=%:8983$ EXLOCAL=127.0.0.1:8983 STATE=ESTABLISHED MIN=0 TRACK=solr "TEXT=Port 8983 (solr), LAN-facing, established"
#
HOST=%^rslr\d{3}t\.
  PORT LOCAL=%:8983$ EXLOCAL=127.0.0.1:8983 STATE=LISTEN MIN=1 TRACK=solr "TEXT=Port 8983 (solr), LAN-facing, listening" GROUP=solr
  PORT LOCAL=%:8983$ EXLOCAL=127.0.0.1:8983 STATE=ESTABLISHED MIN=0 TRACK=solr "TEXT=Port 8983 (solr), LAN-facing, established"
#
HOST=%^rpxy(01[13]|2[23])t\.
  PORT LOCAL=%:8983$ EXLOCAL=127.0.0.1:8983 STATE=LISTEN MIN=1 TRACK=solr "TEXT=Port 8983 (solr), LAN-facing, listening" GROUP=solr
  PORT LOCAL=%:8983$ EXLOCAL=127.0.0.1:8983 STATE=ESTABLISHED MIN=0 TRACK=solr "TEXT=Port 8983 (solr), LAN-facing, established"
#
HOST=%^rslr\d{3}p\.
  PORT LOCAL=%:8983$ EXLOCAL=127.0.0.1:8983 STATE=LISTEN MIN=1 TRACK=solr "TEXT=Port 8983 (solr), LAN-facing, listening" GROUP=solr
  PORT LOCAL=%:8983$ EXLOCAL=127.0.0.1:8983 STATE=ESTABLISHED MIN=0 TRACK=solr "TEXT=Port 8983 (solr), LAN-facing, established"
#
HOST=%^rpxy01[45]p\.
  PORT LOCAL=%:8983$ EXLOCAL=127.0.0.1:8983 STATE=LISTEN MIN=1 TRACK=solr "TEXT=Port 8983 (solr), LAN-facing, listening" GROUP=solr
  PORT LOCAL=%:8983$ EXLOCAL=127.0.0.1:8983 STATE=ESTABLISHED MIN=0 TRACK=solr "TEXT=Port 8983 (solr), LAN-facing, established"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 9000 monitor
#
# Ruby on Rails-based services for PubSys (pubsys-svc) are provided
# through port 9000 and hosted only on dedicated SLR servers.
#
# Port 9000 (pubsys-svc) LAN-facing service is expected present on:
#
# * RHEL SLR boxes: rslr\d{3}[dpt]
#
HOST=%^rsvc\d{3}d\.
  PORT LOCAL=%:9000$ EXLOCAL=127.0.0.1:9000 STATE=LISTEN MIN=1 TRACK=pubsys-svc "TEXT=Port 9000 (pubsys-svc), LAN-facing, listening" GROUP=pubsys
  PORT LOCAL=%:9000$ EXLOCAL=127.0.0.1:9000 STATE=ESTABLISHED MIN=0 TRACK=pubsys-svc "TEXT=Port 9000 (pubsys-svc), LAN-facing, established"
#
HOST=%^rsvc\d{3}t\.
  PORT LOCAL=%:9000$ EXLOCAL=127.0.0.1:9000 STATE=LISTEN MIN=1 TRACK=pubsys-svc "TEXT=Port 9000 (pubsys-svc), LAN-facing, listening" GROUP=pubsys
  PORT LOCAL=%:9000$ EXLOCAL=127.0.0.1:9000 STATE=ESTABLISHED MIN=0 TRACK=pubsys-svc "TEXT=Port 9000 (pubsys-svc), LAN-facing, established"
#
HOST=%^rsvc\d{3}p\.
  PORT LOCAL=%:9000$ EXLOCAL=127.0.0.1:9000 STATE=LISTEN MIN=1 TRACK=pubsys-svc "TEXT=Port 9000 (pubsys-svc), LAN-facing, listening" GROUP=pubsys
  PORT LOCAL=%:9000$ EXLOCAL=127.0.0.1:9000 STATE=ESTABLISHED MIN=0 TRACK=pubsys-svc "TEXT=Port 9000 (pubsys-svc), LAN-facing, established"
#
# Sonar, a code analysis tool, also uses port 9000.
#
# Port 9000 (sonar) LAN-facing service is expected present on:
#
# * Sonar host: rutl020d.
#
HOST=%^rutl020d\.
  PORT LOCAL=%:9000$ EXLOCAL=127.0.0.1:9000 STATE=LISTEN MIN=1 TRACK=sonar "TEXT=Port 9000 (sonar), LAN-facing, listening" GROUP=devops
  PORT LOCAL=%:9000$ EXLOCAL=127.0.0.1:9000 STATE=ESTABLISHED MIN=0 TRACK=sonar "TEXT=Port 9000 (sonar), LAN-facing, established"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 10010 (ds_worker) monitor
#

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 10012 (ds_worker) monitor
#
# PubSys Distributed Services (DS) needs an army of workers.  They're
# pretty much constrained to the BIP and PAG farms.
#
# Port 10012 (ds_worker) LAN-facing service is expected present on:
#
# * RHEL BIP boxes: rbip\d{3}[dpt]
# * RHEL PAG boxes: rpag\d{3}[dpt]
#
HOST=%^r(bip|pag)\d{3}d\.
  PORT LOCAL=%:10012$ EXLOCAL=127.0.0.1:10012 STATE=LISTEN MIN=1 TRACK=ds_worker "TEXT=Port 10012 (ds_worker), LAN-facing, listening" GROUP=pubsys
  PORT LOCAL=%:10012$ EXLOCAL=127.0.0.1:10012 STATE=ESTABLISHED MIN=0 TRACK=ds_worker "TEXT=Port 10012 (ds_worker), LAN-facing, established"
#
HOST=%^r(bip|pag)\d{3}t\.
  PORT LOCAL=%:10012$ EXLOCAL=127.0.0.1:10012 STATE=LISTEN MIN=1 TRACK=ds_worker "TEXT=Port 10012 (ds_worker), LAN-facing, listening" GROUP=pubsys
  PORT LOCAL=%:10012$ EXLOCAL=127.0.0.1:10012 STATE=ESTABLISHED MIN=0 TRACK=ds_worker "TEXT=Port 10012 (ds_worker), LAN-facing, established"
#
HOST=%^r(bip|pag)\d{3}p\.
  PORT LOCAL=%:10012$ EXLOCAL=127.0.0.1:10012 STATE=LISTEN MIN=1 TRACK=ds_worker "TEXT=Port 10012 (ds_worker), LAN-facing, listening" GROUP=pubsys
  PORT LOCAL=%:10012$ EXLOCAL=127.0.0.1:10012 STATE=ESTABLISHED MIN=0 TRACK=ds_worker "TEXT=Port 10012 (ds_worker), LAN-facing, established"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Local port 11211 (memcache) monitor
#
# Memcache only runs on dedicated MEM servers in select environments;
# in other environments, it shares space on multi-purposes boxes.
#
# Port 11211 (memcache) LAN-facing service is expected present on:
#
# * RHEL MEM boxes: rmem\d{3}[dpt]
# * Beta servers: rsvc003d
# * Edge servers: rsvc000d, rweb00[01]d
# * QA1 servers: rweb003t
#
HOST=%^r(mem\d{3}|svc00[03]|web0(0[01]))d\.
  PORT LOCAL=%:11211$ EXLOCAL=127.0.0.1:11211 STATE=LISTEN MIN=1 TRACK=memcache "TEXT=Port 11211 (memcache), LAN-facing, listening" GROUP=memcache
  PORT LOCAL=%:11211$ EXLOCAL=127.0.0.1:11211 STATE=ESTABLISHED MIN=0 TRACK=memcache "TEXT=Port 11211 (memcache), LAN-facing, established"
#
HOST=%^r(mem\d{3}|web003)t\.
  PORT LOCAL=%:11211$ EXLOCAL=127.0.0.1:11211 STATE=LISTEN MIN=1 TRACK=memcache "TEXT=Port 11211 (memcache), LAN-facing, listening" GROUP=memcache
  PORT LOCAL=%:11211$ EXLOCAL=127.0.0.1:11211 STATE=ESTABLISHED MIN=0 TRACK=memcache "TEXT=Port 11211 (memcache), LAN-facing, established"
#
HOST=%^rmem\d{3}p\.
  PORT LOCAL=%:11211$ EXLOCAL=127.0.0.1:11211 STATE=LISTEN MIN=1 TRACK=memcache "TEXT=Port 11211 (memcache), LAN-facing, listening" GROUP=memcache
  PORT LOCAL=%:11211$ EXLOCAL=127.0.0.1:11211 STATE=ESTABLISHED MIN=0 TRACK=memcache "TEXT=Port 11211 (memcache), LAN-facing, established"

#######################################################################
###

HOST=%^fnet0\d{2}p\.
  LOAD 1 100 # testing to see when it bumps 1
  MEMACT 3 75 # testing yellow to see it bump


###############################
#### end Devel
###############################

###############################
#### Production systems
###############################

CLASS=prodweb
  LOG /home/nmapp/local/apache/logs/error.log %(?-i)server\sreached\sMaxClients|\[notice\] COLOR=red

CLASS=activemq
  LOG /nm/local/var/log/activemq/activemq.log %(-i)Usage\sManager\sMemory\sLimit\sis\sfull. COLOR=red

#### Rules for specific hosts or groups of hosts

# Monitoring feed files
HOST=radm003p.prod.nandomedia.com
  FILE "%/nm/home/mi/mi000s/mcclatchyinteractive.com/static/fullfeed/.*" red MTIME<3600
  FILE "%/nm/home/mi/mi000s/mcclatchyinteractive.com/static/fullfeed/.*" yellow MTIME<1800
###############################
# FastCGI servers:
# Production # QA1 (PB 12}
HOST=%^rdds0\d{2}p\.
  PROC /nm/local/mi/jumuishi/fcgi-bin/pagebuilder.pl 24 80 red
  PROC /nm/local/mi/registration/fcgi-bin/api_service.pl 2 12 red
  PROC /nm/local/mi/registration/cgi-bin/public.fcgi 12 16 red
  PROC /nm/local/mi/search_system/cgi-bin/public.fcgi 12 16 red
  PROC /nm/local/mi/survey/cgi-bin/public.fcgi 2 12 red
HOST=%^rdds0((1[34]|26)t)\.
  PROC /nm/local/mi/jumuishi/fcgi-bin/pagebuilder.pl 12 40 red
  PROC /nm/local/mi/registration/fcgi-bin/api_service.pl 2 3 red
  PROC /nm/local/mi/registration/cgi-bin/public.fcgi 4 4 red
  PROC /nm/local/mi/search_system/cgi-bin/public.fcgi 4 4 red
  PROC /nm/local/mi/survey/cgi-bin/public.fcgi 2 3 red
HOST=%^rpub0([^5]\dp|0[2-4]t)\. EXHOST=%^rpub00[0579]p\.
  PROC /nm/local/mi/jumuishi/fcgi-bin/pagebuilder.pl 12 22 red
  PROC /nm/local/mi/registration/fcgi-bin/api_service.pl 2 3 red
  PROC /nm/local/mi/registration/cgi-bin/public.fcgi 4 4 red
  PROC /nm/local/mi/search_system/cgi-bin/public.fcgi 4 4 red
  PROC /nm/local/mi/survey/cgi-bin/public.fcgi 2 3 red
# QA2 (PB 4)
HOST=%^r(dds025|pub001)t\.
  PROC /nm/local/mi/jumuishi/fcgi-bin/pagebuilder.pl 4 8 red
  PROC /nm/local/mi/registration/fcgi-bin/api_service.pl 2 3 red
  PROC /nm/local/mi/registration/cgi-bin/public.fcgi 4 4 red
  PROC /nm/local/mi/search_system/cgi-bin/public.fcgi 4 4 red
  PROC /nm/local/mi/survey/cgi-bin/public.fcgi 2 3 red

###############################
# Escenic pre/pub servers
HOST=%^r(pre\d{3}[dpt]|pub0(14d|0[0579]p|(08|13)t)|utl025d)\.
  PROC "%java.*catalina\.home" 1 -1 red
  MEMACT 100 101
HOST=%^rpre\d{3}[dpt]\.
  PROC /usr/sbin/httpd.worker 1 10 TRACK=httpd EXHOST=rpre000p.prod.nandomedia.com

###############################
# NFS share storage
HOST=$STORAGE_HOSTS
  DISK /ece-prod0/akamai-log 95 98 GROUP=ecsysem
  DISK /ece-prod0/ece-feeds-in 95 98 GROUP=ecsysem
  DISK /ece-prod0/ece-feeds-out 95 98 GROUP=ecsysem
  DISK /ece-prod0/ece-log 95 98 GROUP=ecsysem
  DISK /ece-prod0/ece-media 95 98 GROUP=ecsysem
# end NFS share storage
##############################

# the catch all case

#### DO NOT PUT "PROCS"or PORTS IN DEFAULT SECTION--it will get applied to all

DEFAULT
  CLOCK 15
  DISK /home 95 98 GROUP=support
  DISK /mnt IGNORE
  DISK /nm/local 95 98 GROUP=support
  DISK /var 95 98 GROUP=support
  DISK * 95 98 GROUP=system
  LOAD 5.0 7.0
  MEMACT 90 97
  MEMPHYS 100 101
  MEMSWAP 70 90
  UP 30m
  # PORT/PROC TESTS will get propagated to all hosts!
  PROC %(^|/)cfexecd$ 0 0 yellow GROUP=system EXHOST=%^(a|rcgi0(0[23]|1[01])p\.)
  PROC %(^|/)cf-execd$ 1 1 yellow GROUP=system EXHOST=%^(a|rcgi0(0[23]|1[01])p\.)
  # For some reason, the EXHOST for the DEFAULT section doesn't
  # exclude the excluded host from these PROC tests, so we have to
  # make an EXHOST regex for these (if needed):
  PROC %(^|/)cf-serverd$ 0 0 yellow GROUP=system EXHOST=%^(a|r(adm001|utl(01[0-2]|048|400))p\.)
  PROC %(^|/)cf-monitord$ 0 0 yellow GROUP=system EXHOST=%^a
  PROC %(^|/)cfenvd$ 0 0 yellow GROUP=system EXHOST=%^a
  PROC ypbind 1 red GROUP=system EXHOST=%^(a|rutl40[0,2]p\.)
  PROC crond 1 yellow GROUP=system EXHOST=%^a
  PROC tripwire 0 4 yellow GROUP=system EXHOST=%^a

